import{_ as l,r as s,o,c as r,b as e,e as a,w as n,a as c,d as t}from"./app-DFklLwn2.js";const _="/online_notesV2/assets/image-20230102230918138-e7lhtGb1.png",h="/online_notesV2/assets/image-20230102231324523-2mG_PVwI.png",m="/online_notesV2/assets/image-20230102231527208-CYgVphLx.png",p="/online_notesV2/assets/image-20230102232226936-BeMH5e06.png",g="/online_notesV2/assets/image-20230102233116572-Dwj0SqPd.png",d="/online_notesV2/assets/image-20230102233230594-DpJpxIng.png",u={},f=e("h1",{id:"组合与继承",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#组合与继承"},[e("span",null,"组合与继承")])],-1),x={class:"table-of-contents"},y=c('<h2 id="_0-类之间的三种关系" tabindex="-1"><a class="header-anchor" href="#_0-类之间的三种关系"><span>0.类之间的三种关系</span></a></h2><ul><li>Inheritance (繼承)</li><li>Composition (複合)</li><li>Delegation (委託)</li></ul><h2 id="_1-composition-has-a的关系" tabindex="-1"><a class="header-anchor" href="#_1-composition-has-a的关系"><span>1. Composition -- has - a的关系</span></a></h2><p>其实普通的class里面存在别的class就是has-a。无论是自定义的class还是语言已经定义好的class。因此，复合关系是非常普遍的。</p><img src="'+_+'" alt="image-20230102230918138" style="zoom:50%;"><img src="'+h+'" alt="image-20230102231324523" style="zoom:50%;"><ul><li>从内存的角度</li></ul><img src="'+m+'" alt="image-20230102231527208" style="zoom:50%;"><ul><li>默认构造，由内而外。如果不显式写出初始值列，则初始值列其实就是调用默认构造函数。</li></ul><h2 id="_2-delegation-委托" tabindex="-1"><a class="header-anchor" href="#_2-delegation-委托"><span>2. Delegation 委托</span></a></h2><ul><li>Composition by reference</li><li>委托的双方生命周期是不同步的</li></ul><img src="'+p+'" alt="image-20230102232226936" style="zoom:50%;"><ul><li><p>编译防火墙：</p><ul><li>哪怕改动，只有右边是需要编译的，左边是不需要的</li></ul></li><li><p>上面的例子还展示出了一种共享的特性，方便使用reference counting。</p><ul><li>如果只是拷贝一个内存完全一样的string。那么完全可以使用引用计数去进行共享，节省内存。</li><li>如果想改动内容则copy on write。即当改动的时候，才真正拷贝一个副本去进行变动。</li></ul></li></ul><h2 id="_3-inheritance-继承" tabindex="-1"><a class="header-anchor" href="#_3-inheritance-继承"><span>3. inheritance 继承</span></a></h2><img src="'+g+'" alt="image-20230102233116572" style="zoom:50%;"><img src="'+d+'" alt="image-20230102233230594" style="zoom:50%;">',16);function V(b,B){const i=s("router-link");return o(),r("div",null,[f,e("nav",x,[e("ul",null,[e("li",null,[a(i,{to:"#_0-类之间的三种关系"},{default:n(()=>[t("0.类之间的三种关系")]),_:1})]),e("li",null,[a(i,{to:"#_1-composition-has-a的关系"},{default:n(()=>[t("1. Composition -- has - a的关系")]),_:1})]),e("li",null,[a(i,{to:"#_2-delegation-委托"},{default:n(()=>[t("2. Delegation 委托")]),_:1})]),e("li",null,[a(i,{to:"#_3-inheritance-继承"},{default:n(()=>[t("3. inheritance 继承")]),_:1})])])]),y])}const v=l(u,[["render",V],["__file","11.组合与继承.html.vue"]]),C=JSON.parse('{"path":"/Programming/cpp/11.%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF.html","title":"组合与继承","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"0.类之间的三种关系","slug":"_0-类之间的三种关系","link":"#_0-类之间的三种关系","children":[]},{"level":2,"title":"1. Composition -- has - a的关系","slug":"_1-composition-has-a的关系","link":"#_1-composition-has-a的关系","children":[]},{"level":2,"title":"2. Delegation 委托","slug":"_2-delegation-委托","link":"#_2-delegation-委托","children":[]},{"level":2,"title":"3. inheritance 继承","slug":"_3-inheritance-继承","link":"#_3-inheritance-继承","children":[]}],"git":{"updatedTime":1706457681000,"contributors":[{"name":"henryhuanghenry","email":"henryhuanghenry@outlook.com","commits":1}]},"filePathRelative":"Programming/cpp/11.组合与继承.md"}');export{v as comp,C as data};
