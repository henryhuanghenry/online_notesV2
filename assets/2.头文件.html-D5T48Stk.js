import{_ as t,r as s,o as c,c as d,b as e,e as i,w as n,a as r,d as a}from"./app-DFklLwn2.js";const o="/online_notesV2/assets/image-20221204195829689-C0HGsaxb.png",u="/online_notesV2/assets/image-20221204200358657-CtGRVZem.png",h={},p=e("h1",{id:"c-头文件",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#c-头文件"},[e("span",null,"C++头文件")])],-1),m={class:"table-of-contents"},_=r('<p><img src="'+o+'" alt="image-20221204195829689"></p><h2 id="h-和-cpp" tabindex="-1"><a class="header-anchor" href="#h-和-cpp"><span>.h 和 .cpp</span></a></h2><ul><li>在头文件中声明类以及类的成员函数 <ul><li>声明就是向编译器承诺，在某个地方我会定义这个东西。</li></ul></li><li>在CPP的文件中定义类以及成员函数</li></ul><img src="'+u+`" alt="image-20221204200358657" style="zoom:50%;"><ul><li>必须要在定义以及使用类/函数的CPP文件中，include这个头文件</li></ul><h2 id="include" tabindex="-1"><a class="header-anchor" href="#include"><span>include</span></a></h2><h3 id="作用" tabindex="-1"><a class="header-anchor" href="#作用"><span>作用</span></a></h3><ul><li>#代表编译预处理指令，在编译预处理阶段，#include会把需要被include中的代码以及当前的代码合并成一个大的代码文件。</li><li>因此，include的作用就是把需要的代码插入到需要的地方</li></ul><h3 id="和-的区别" tabindex="-1"><a class="header-anchor" href="#和-的区别"><span>&lt;&gt;和“”的区别</span></a></h3><ul><li>“”首先到当前的目录(cpp所在的目录)去寻找文件</li><li>#include&lt;.h&gt;首先到编译器认定的系统存放头文件的目录去找。比如可能是/user/include/</li><li>#include&lt;&gt; 和上面那个一样，但是iostream是有两个版本的，一个有.h一个没有</li></ul><h3 id="条件编译-头文件的防卫式声明" tabindex="-1"><a class="header-anchor" href="#条件编译-头文件的防卫式声明"><span>条件编译--头文件的防卫式声明</span></a></h3><p>不进行条件编译容易产生重复定义。</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>#ifndef
#define 宏名字
...
#endif
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="编译生成文件" tabindex="-1"><a class="header-anchor" href="#编译生成文件"><span>编译生成文件</span></a></h2><ul><li>.ii 合并后的代码文件，给编译器做编译</li><li>.s 汇编代码</li><li>.o 目标代码</li><li>.out 生成的可执行文件</li></ul><p>编译的时候是单元编译，也就是每个CPP是单独编译的。每个cpp会形成单独的.ii .s .o输出文件。</p>`,16);function g(f,v){const l=s("router-link");return c(),d("div",null,[p,e("nav",m,[e("ul",null,[e("li",null,[i(l,{to:"#h-和-cpp"},{default:n(()=>[a(".h 和 .cpp")]),_:1})]),e("li",null,[i(l,{to:"#include"},{default:n(()=>[a("include")]),_:1}),e("ul",null,[e("li",null,[i(l,{to:"#作用"},{default:n(()=>[a("作用")]),_:1})]),e("li",null,[i(l,{to:"#和-的区别"},{default:n(()=>[a("<>和“”的区别")]),_:1})]),e("li",null,[i(l,{to:"#条件编译-头文件的防卫式声明"},{default:n(()=>[a("条件编译--头文件的防卫式声明")]),_:1})])])]),e("li",null,[i(l,{to:"#编译生成文件"},{default:n(()=>[a("编译生成文件")]),_:1})])])]),_])}const x=t(h,[["render",g],["__file","2.头文件.html.vue"]]),k=JSON.parse('{"path":"/Programming/cpp/2.%E5%A4%B4%E6%96%87%E4%BB%B6.html","title":"C++头文件","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":".h 和 .cpp","slug":"h-和-cpp","link":"#h-和-cpp","children":[]},{"level":2,"title":"include","slug":"include","link":"#include","children":[{"level":3,"title":"作用","slug":"作用","link":"#作用","children":[]},{"level":3,"title":"<>和“”的区别","slug":"和-的区别","link":"#和-的区别","children":[]},{"level":3,"title":"条件编译--头文件的防卫式声明","slug":"条件编译-头文件的防卫式声明","link":"#条件编译-头文件的防卫式声明","children":[]}]},{"level":2,"title":"编译生成文件","slug":"编译生成文件","link":"#编译生成文件","children":[]}],"git":{"updatedTime":1706457681000,"contributors":[{"name":"henryhuanghenry","email":"henryhuanghenry@outlook.com","commits":1}]},"filePathRelative":"Programming/cpp/2.头文件.md"}');export{x as comp,k as data};
