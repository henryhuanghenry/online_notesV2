import{_ as o,r as s,o as d,c,b as l,e,w as a,d as i,a as r}from"./app-DFklLwn2.js";const u={},p=l("h1",{id:"面试常考",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#面试常考"},[l("span",null,"面试常考")])],-1),h={class:"table-of-contents"},_={href:"https://github.com/jackfrued/Python-Interview-Bible/blob/master/Python%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-%E5%9F%BA%E7%A1%80%E7%AF%87-2020.md",target:"_blank",rel:"noopener noreferrer"},m={href:"https://www.nowcoder.com/discuss/988986?type=all&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_all_nctrack&gio_id=70560667230F7991D3A8FAF40FAF98ED-1658392697801",target:"_blank",rel:"noopener noreferrer"},v=l("li",null,[l("p",null,"可变对象和不可变对象："),l("ul",null,[l("li",null,"可变：List, set, dict"),l("li",null,"不可变：字符串，数字，元组"),l("li",null,"集合的元素、字典的键值必须为不可变(可哈希的对象)")])],-1),b=r(`<h2 id="动态类型" tabindex="-1"><a class="header-anchor" href="#动态类型"><span>动态类型</span></a></h2><h3 id="变量和对象" tabindex="-1"><a class="header-anchor" href="#变量和对象"><span>变量和对象</span></a></h3><ul><li><p>变量</p><ul><li>变量的类型在运行时自动决定(其实变量是没有类型的)</li><li>变量就单纯的是个名字，使用变量是在使用其引用的对象</li><li>对变量赋值，是创建变量到对象的引用，而不是复制</li></ul></li><li><p>对象：</p><ul><li><p>对象具有两个头部信息：类型标志符、引用计数器</p></li><li><p>类型属于对象而不是变量</p></li><li><p>对不可变对象</p><ul><li><p>共享引用：两个变量指向同一个不可变对象</p><ul><li><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code>a <span class="token operator">=</span> <span class="token number">3</span>
b <span class="token operator">=</span> <span class="token number">3</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>变量只是指向对象的指针，并不指向一个可改变的内存区域</p></li></ul></li><li><p>对可变对象</p></li></ul></li><li><p>对象的垃圾回收</p><ul><li>基于引用计数器，引用计数器清零即被回收</li><li>但是需要对循环引用进行检测</li></ul></li></ul><h3 id="相等的-is-和" tabindex="-1"><a class="header-anchor" href="#相等的-is-和"><span>相等的 is 和 ==</span></a></h3><ul><li>== 比较的是对象的值</li><li>而is比较的是，两个变量是否引用同一个对象</li></ul><h3 id="浅拷贝和深拷贝" tabindex="-1"><a class="header-anchor" href="#浅拷贝和深拷贝"><span>浅拷贝和深拷贝</span></a></h3><ul><li>浅拷贝--切片b=a[1:]，工厂函数b=list(a),.copy()都是浅拷贝 <ul><li>只会拷贝对象的顶层</li><li>即在新的地址处创建了一个对象</li><li>但是对象内的各个子对象不会发生拷贝 <ul><li>比如对List进行浅拷贝，其中存有的元素不会发生拷贝</li><li>即新的List中的每个元素与旧的List的每个元素共享引用</li></ul></li></ul></li><li>深拷贝--.deepcopy(a) <ul><li>深度的拷贝整个对象</li><li>在新的地址处创构建一个对象</li><li>对象内的各个子对象也发生拷贝，嵌套式的进行</li><li>新对象的子对象不与旧对象的子对象共享引用</li></ul></li></ul><h2 id="作用域" tabindex="-1"><a class="header-anchor" href="#作用域"><span>作用域</span></a></h2><ul><li>全局作用域： <ul><li>外围模块导入的变量是全局作用域</li><li>声明为global的也为全局作用域 <ul><li>要在局部作用域使用外层def定义的变量，可以用nonlocal声明</li></ul></li><li>全局作用域仅限于一个文件</li></ul></li><li>局部作用域： <ul><li>定义在def内的变量名是局部作用域</li><li>在上一次def定义的变量，可以在它嵌套的def使用</li><li>函数的每次调用都会创建一个新的局部作用域 <ul><li>定义在函数内部的函数可以认为是临时函数，只在上层函数运行时才存在</li></ul></li></ul></li></ul><p>作用域查找原则：LEGB</p><h2 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包"><span>闭包</span></a></h2><ul><li>嵌套函数</li><li>内部函数直接引用了外部函数的变量</li><li>外部函数的返回值是内部的函数</li></ul><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">a</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token keyword">def</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    		<span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
    <span class="token keyword">return</span> b
  
  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="迭代器" tabindex="-1"><a class="header-anchor" href="#迭代器"><span>迭代器</span></a></h2><ul><li><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>迭代器（iterator）是一种可以记住遍历对象位置的对象，对于序列的数据结构我们可以使用iter（）方法创建迭代器，之后调用next（）函数进行迭代输出。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在我们访问可迭代对象的元素时可以：</p><p>1.使用iter（）方法创建迭代器</p><p>2.使用next（）函数进行迭代</p><p>3.当迭代元素用尽时会抛出 StopIteration 异常</p></li></ul><h2 id="生成器" tabindex="-1"><a class="header-anchor" href="#生成器"><span>生成器</span></a></h2><ul><li><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>使用了 yield（产出） 的函数被称为生成器（generator）。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解<strong>生成器就是一个迭代器</strong></p></li><li><p>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停（挂起）并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</p></li><li><p>调用生成器的主要目的是节省存储空间，假如我们需要打印一个含有1000个有规律的元素列表，如果我们创建了这个列表，那么将会占用很大的空间，使用生成器时仅会保存当前的运行信息，并在下次执行时从当前位置开始执行，节省了空间</p></li></ul><h2 id="装饰器" tabindex="-1"><a class="header-anchor" href="#装饰器"><span>装饰器</span></a></h2><p>https://blog.csdn.net/weixin_44992737/article/details/125868592</p><ul><li>装饰器本质上是一个闭包。返回的是一个python函数。</li><li>装饰器可以在不改动原函数的情况下，对函数增加一些功能。比如打log。</li><li>多个装饰器的话，从内到外执行。</li></ul><h2 id="一些面试问题" tabindex="-1"><a class="header-anchor" href="#一些面试问题"><span>一些面试问题</span></a></h2><ul><li><p><code>__init__</code>和<code>__new__</code>方法有什么区别？</p><ul><li>Python中调用构造器创建对象属于两阶段构造过程，首先执行<code>__new__</code>方法获得保存对象所需的内存空间，再通过<code>__init__</code>执行对内存空间数据的填充（对象属性的初始化）。</li><li><code>__new__</code>方法的返回值是创建好的Python对象（的引用），而<code>__init__</code>方法的第一个参数就是这个对象（的引用），所以在<code>__init__</code>中可以完成对对象的初始化操作。<code>__new__</code>是类方法，它的第一个参数是类，<code>__init__</code>是对象方法，它的第一个参数是对象。</li></ul></li><li><p>迭代器和生成器</p><ul><li>如何更好地理解Python迭代器和生成器？ - 赖明星的回答 - 知乎 https://www.zhihu.com/question/20829330/answer/133606850</li></ul></li><li><p>的</p></li><li><p>的</p></li><li></li><li></li><li></li><li></li><li></li><li></li></ul>`,22);function g(f,k){const n=s("router-link"),t=s("ExternalLinkIcon");return d(),c("div",null,[p,l("nav",h,[l("ul",null,[l("li",null,[e(n,{to:"#动态类型"},{default:a(()=>[i("动态类型")]),_:1}),l("ul",null,[l("li",null,[e(n,{to:"#变量和对象"},{default:a(()=>[i("变量和对象")]),_:1})]),l("li",null,[e(n,{to:"#相等的-is-和"},{default:a(()=>[i("相等的 is 和 ==")]),_:1})]),l("li",null,[e(n,{to:"#浅拷贝和深拷贝"},{default:a(()=>[i("浅拷贝和深拷贝")]),_:1})])])]),l("li",null,[e(n,{to:"#作用域"},{default:a(()=>[i("作用域")]),_:1})]),l("li",null,[e(n,{to:"#闭包"},{default:a(()=>[i("闭包")]),_:1})]),l("li",null,[e(n,{to:"#迭代器"},{default:a(()=>[i("迭代器")]),_:1})]),l("li",null,[e(n,{to:"#生成器"},{default:a(()=>[i("生成器")]),_:1})]),l("li",null,[e(n,{to:"#装饰器"},{default:a(()=>[i("装饰器")]),_:1})]),l("li",null,[e(n,{to:"#一些面试问题"},{default:a(()=>[i("一些面试问题")]),_:1})])])]),l("ul",null,[l("li",null,[l("p",null,[l("a",_,[i("github上的面经"),e(t)])])]),l("li",null,[l("p",null,[l("a",m,[i("牛客网编程李狗蛋的面经"),e(t)])])]),v]),b])}const y=o(u,[["render",g],["__file","python面试常考.html.vue"]]),w=JSON.parse('{"path":"/Programming/python/python%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83.html","title":"面试常考","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"动态类型","slug":"动态类型","link":"#动态类型","children":[{"level":3,"title":"变量和对象","slug":"变量和对象","link":"#变量和对象","children":[]},{"level":3,"title":"相等的 is 和 ==","slug":"相等的-is-和","link":"#相等的-is-和","children":[]},{"level":3,"title":"浅拷贝和深拷贝","slug":"浅拷贝和深拷贝","link":"#浅拷贝和深拷贝","children":[]}]},{"level":2,"title":"作用域","slug":"作用域","link":"#作用域","children":[]},{"level":2,"title":"闭包","slug":"闭包","link":"#闭包","children":[]},{"level":2,"title":"迭代器","slug":"迭代器","link":"#迭代器","children":[]},{"level":2,"title":"生成器","slug":"生成器","link":"#生成器","children":[]},{"level":2,"title":"装饰器","slug":"装饰器","link":"#装饰器","children":[]},{"level":2,"title":"一些面试问题","slug":"一些面试问题","link":"#一些面试问题","children":[]}],"git":{"updatedTime":1706457681000,"contributors":[{"name":"henryhuanghenry","email":"henryhuanghenry@outlook.com","commits":1}]},"filePathRelative":"Programming/python/python面试常考.md"}');export{y as comp,w as data};
