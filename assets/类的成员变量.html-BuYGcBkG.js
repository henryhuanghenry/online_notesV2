import{_ as s,r as t,o,c as r,b as e,e as i,w as n,a as c,d as a}from"./app-DFklLwn2.js";const d="/online_notesV2/assets/image-20221204202926614-pYPdexZs.png",m="/online_notesV2/assets/image-20221204205241111-hv0mhSFj.png",u="/online_notesV2/assets/image-20221204205452435-P9N-bLbw.png",p={},_=e("h1",{id:"类的成员变量",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#类的成员变量"},[e("span",null,"类的成员变量")])],-1),h={class:"table-of-contents"},v=c('<h2 id="成员变量、函数参数、局部变量" tabindex="-1"><a class="header-anchor" href="#成员变量、函数参数、局部变量"><span>成员变量、函数参数、局部变量</span></a></h2><ul><li><p>函数参数和局部变量是相同的</p><ul><li>只是他们存在于堆栈的地方不同（？？）</li><li>在进入函数之前，这些变量都不存在。</li><li>进入函数之后，函数参数和局部变量就存在了。</li><li>他们作用域相同，声明周期相同。</li></ul></li><li><p>若函数中存在和成员变量重名的局部变量，则当前访问的其实是局部变量，而非成员变量。</p><ul><li>即变量的就近原则</li></ul></li><li><p>成员变量：</p><ul><li><p>在类的声明时被声明，但是那个不是定义。（看下面的代码）</p><ul><li>成员变量不属于类，而是属于对象的。即这个成员变量是定义给对象的。</li><li>在用这个类去定义变量的时候，这个成员变量就定义为了那个变量的成员变量了。</li></ul></li><li><p>作用域：在类的所有成员函数中可被访问。</p></li></ul></li></ul><img src="'+d+`" alt="image-20221204202926614" style="zoom:50%;"><div class="language-C++ line-numbers-mode" data-ext="C++" data-title="C++"><pre class="language-C++"><code>class A{
    private:
    	int i; // 这里只是声明了一个成员变量i，但不是定义。
    public:
    	void f();
}

A a; //这里定义了一个A的对象a，也定义了a.i
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="成员函数" tabindex="-1"><a class="header-anchor" href="#成员函数"><span>成员函数</span></a></h2><ul><li>成员函数是属于类的，而不是属于对象的。 <ul><li>其实就是要阐述一个概念，对于每个对象来说，他们的成员函数都是类的那些成员函数。</li><li>而对于成员变量来说，每个成员变量都是不同的。</li><li>那成员函数怎么知道它在操作哪个对象呢？其实就是this指针了。</li></ul></li></ul><img src="`+m+'" alt="image-20221204205241111" style="zoom:50%;"><img src="'+u+'" alt="image-20221204205452435" style="zoom:50%;">',8);function g(b,f){const l=t("router-link");return o(),r("div",null,[_,e("nav",h,[e("ul",null,[e("li",null,[i(l,{to:"#成员变量、函数参数、局部变量"},{default:n(()=>[a("成员变量、函数参数、局部变量")]),_:1})]),e("li",null,[i(l,{to:"#成员函数"},{default:n(()=>[a("成员函数")]),_:1})])])]),v])}const k=s(p,[["render",g],["__file","类的成员变量.html.vue"]]),y=JSON.parse('{"path":"/Programming/cpp/%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F.html","title":"类的成员变量","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"成员变量、函数参数、局部变量","slug":"成员变量、函数参数、局部变量","link":"#成员变量、函数参数、局部变量","children":[]},{"level":2,"title":"成员函数","slug":"成员函数","link":"#成员函数","children":[]}],"git":{"updatedTime":1706457681000,"contributors":[{"name":"henryhuanghenry","email":"henryhuanghenry@outlook.com","commits":1}]},"filePathRelative":"Programming/cpp/类的成员变量.md"}');export{k as comp,y as data};
