import{_ as n,a as r,b as s}from"./image-20221226235146438-YWznVd-K.js";import{_ as c,r as d,o,c as u,b as e,e as a,w as i,a as p,d as t}from"./app-DFklLwn2.js";const h={},m=e("h1",{id:"堆和栈",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#堆和栈"},[e("span",null,"堆和栈")])],-1),b={class:"table-of-contents"},v=p('<img src="'+n+`" alt="image-20221226231950601" style="zoom:50%;"><h2 id="stack-object" tabindex="-1"><a class="header-anchor" href="#stack-object"><span>stack object</span></a></h2><ul><li>在作用域结束的时候，对象的析构函数被调用，内存被释放。</li><li>static local object 声明在作用域结束的时候还存在，直到整个程序结束的才会结束。</li><li>global object，不再任何一个大括号内，生命周期是直到整个程序结束的才会结束。</li></ul><h2 id="heap-object" tabindex="-1"><a class="header-anchor" href="#heap-object"><span>heap object</span></a></h2><ul><li>其生命从内存分配开始，到手动内存回收为止</li><li>如果不手动进行回收，则会发生内存泄露。 <ul><li>即指向某个内存的指针的生命周期结束了，但是内存所存储的对象的生命周期没有结束。内存所存储的数据依然存在。</li><li>但是我们再也没有机会释放指针指向的内存了，因为指针不存在了。</li></ul></li></ul><h2 id="new的一种分解" tabindex="-1"><a class="header-anchor" href="#new的一种分解"><span>new的一种分解</span></a></h2><ul><li>分配内存 <ul><li>operator new(sizeof(对象))</li><li>operator new 内部调用的是malloc()</li></ul></li><li>类型转换</li><li>构造函数</li></ul><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>Complex * pc = new Complex(1, 2) //调用new
//等价于以下
Complex * pc;
void * mem = operator new(sizeof(Complex)); //分解1 分配内存
pc = static_cast&lt;Complex*&gt;(mem); // 类型转换
pc-&gt;Complex::Complex(1,2); // 调用构造函数
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="delete的分解" tabindex="-1"><a class="header-anchor" href="#delete的分解"><span>delete的分解</span></a></h2><ul><li>先调用析构函数</li><li>再释放内存 <ul><li>内部调用的是free</li></ul></li></ul><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>某个对象的指针ps
调用析构函数(ps);
调用operator delete(ps);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="array-new与array-delete" tabindex="-1"><a class="header-anchor" href="#array-new与array-delete"><span>array new与array delete</span></a></h2><p>不搭配使用会出现泄露，看内存分配那一节</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>object *ptr= new object[n];
delete [] ptr;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="内存的分配" tabindex="-1"><a class="header-anchor" href="#内存的分配"><span>内存的分配</span></a></h2><p><img src="`+r+'" alt="image-20221226234954518"></p><p><img src="'+s+'" alt="image-20221226235146438"></p><ul><li>左边是调试模式右边是relase模式</li><li>如果array new和array delete不搭配使用的话，会存在什么问题呢？ <ul><li>如果不使用array delete，系统不知道分配的内存是数组，也就不知道存在多少个对象。</li><li>调用array delete，会对数组的每个对象都调用一次delete；否则只调用一次。</li></ul></li><li>内存泄露在哪里？ <ul><li>比如string，其实内部是有指针的。</li><li><strong>没有调用array delete，如果对象有指针，会使得指针指向的内存没有被安全释放；泄露的是指针指向的那些内存。</strong></li></ul></li></ul>',18);function _(g,f){const l=d("router-link");return o(),u("div",null,[m,e("nav",b,[e("ul",null,[e("li",null,[a(l,{to:"#stack-object"},{default:i(()=>[t("stack object")]),_:1})]),e("li",null,[a(l,{to:"#heap-object"},{default:i(()=>[t("heap object")]),_:1})]),e("li",null,[a(l,{to:"#new的一种分解"},{default:i(()=>[t("new的一种分解")]),_:1})]),e("li",null,[a(l,{to:"#delete的分解"},{default:i(()=>[t("delete的分解")]),_:1})]),e("li",null,[a(l,{to:"#array-new与array-delete"},{default:i(()=>[t("array new与array delete")]),_:1})]),e("li",null,[a(l,{to:"#内存的分配"},{default:i(()=>[t("内存的分配")]),_:1})])])]),v])}const x=c(h,[["render",_],["__file","虚函数与多态.html.vue"]]),j=JSON.parse('{"path":"/Programming/cpp/%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%A4%9A%E6%80%81.html","title":"堆和栈","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"stack object","slug":"stack-object","link":"#stack-object","children":[]},{"level":2,"title":"heap object","slug":"heap-object","link":"#heap-object","children":[]},{"level":2,"title":"new的一种分解","slug":"new的一种分解","link":"#new的一种分解","children":[]},{"level":2,"title":"delete的分解","slug":"delete的分解","link":"#delete的分解","children":[]},{"level":2,"title":"array new与array delete","slug":"array-new与array-delete","link":"#array-new与array-delete","children":[]},{"level":2,"title":"内存的分配","slug":"内存的分配","link":"#内存的分配","children":[]}],"git":{"updatedTime":1706457681000,"contributors":[{"name":"henryhuanghenry","email":"henryhuanghenry@outlook.com","commits":1}]},"filePathRelative":"Programming/cpp/虚函数与多态.md"}');export{x as comp,j as data};
