# 面试常考

[[TOC]]

- [github上的面经](https://github.com/jackfrued/Python-Interview-Bible/blob/master/Python%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-%E5%9F%BA%E7%A1%80%E7%AF%87-2020.md)
- [牛客网编程李狗蛋的面经](https://www.nowcoder.com/discuss/988986?type=all&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_all_nctrack&gio_id=70560667230F7991D3A8FAF40FAF98ED-1658392697801)



- 可变对象和不可变对象：
  - 可变：List, set, dict
  - 不可变：字符串，数字，元组
  - 集合的元素、字典的键值必须为不可变(可哈希的对象)

## 动态类型

### 变量和对象

- 变量

  - 变量的类型在运行时自动决定(其实变量是没有类型的)
  - 变量就单纯的是个名字，使用变量是在使用其引用的对象
  - 对变量赋值，是创建变量到对象的引用，而不是复制

- 对象：

  - 对象具有两个头部信息：类型标志符、引用计数器

  - 类型属于对象而不是变量

  - 对不可变对象

    - 共享引用：两个变量指向同一个不可变对象

      - ```python
        a = 3
        b = 3
        ```
    - 变量只是指向对象的指针，并不指向一个可改变的内存区域

  - 对可变对象

- 对象的垃圾回收

  - 基于引用计数器，引用计数器清零即被回收
  - 但是需要对循环引用进行检测

### 相等的 is 和 ==

- == 比较的是对象的值
- 而is比较的是，两个变量是否引用同一个对象

### 浅拷贝和深拷贝

- 浅拷贝--切片b=a[1:]，工厂函数b=list(a),.copy()都是浅拷贝
  - 只会拷贝对象的顶层
  - 即在新的地址处创建了一个对象
  - 但是对象内的各个子对象不会发生拷贝
    - 比如对List进行浅拷贝，其中存有的元素不会发生拷贝
    - 即新的List中的每个元素与旧的List的每个元素共享引用
- 深拷贝--.deepcopy(a)
  - 深度的拷贝整个对象
  - 在新的地址处创构建一个对象
  - 对象内的各个子对象也发生拷贝，嵌套式的进行
  - 新对象的子对象不与旧对象的子对象共享引用

## 作用域

- 全局作用域：
  - 外围模块导入的变量是全局作用域
  - 声明为global的也为全局作用域
    - 要在局部作用域使用外层def定义的变量，可以用nonlocal声明
  - 全局作用域仅限于一个文件
- 局部作用域：
  - 定义在def内的变量名是局部作用域
  - 在上一次def定义的变量，可以在它嵌套的def使用
  - 函数的每次调用都会创建一个新的局部作用域
    - 定义在函数内部的函数可以认为是临时函数，只在上层函数运行时才存在

作用域查找原则：LEGB

## 闭包

- 嵌套函数
- 内部函数直接引用了外部函数的变量
- 外部函数的返回值是内部的函数

```python
def a(x):
		def b():
    		print(x)
    return b
  
  
```

## 迭代器

- ```
  迭代器（iterator）是一种可以记住遍历对象位置的对象，对于序列的数据结构我们可以使用iter（）方法创建迭代器，之后调用next（）函数进行迭代输出。
  ```

  在我们访问可迭代对象的元素时可以：

  1.使用iter（）方法创建迭代器

  2.使用next（）函数进行迭代

  3.当迭代元素用尽时会抛出 StopIteration 异常

## 生成器

- ```
  使用了 yield（产出） 的函数被称为生成器（generator）。
  ```

- 跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解**生成器就是一个迭代器**

- 在调用生成器运行的过程中，每次遇到 yield 时函数会暂停（挂起）并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。

- 调用生成器的主要目的是节省存储空间，假如我们需要打印一个含有1000个有规律的元素列表，如果我们创建了这个列表，那么将会占用很大的空间，使用生成器时仅会保存当前的运行信息，并在下次执行时从当前位置开始执行，节省了空间

## 装饰器

https://blog.csdn.net/weixin_44992737/article/details/125868592

- 装饰器本质上是一个闭包。返回的是一个python函数。
- 装饰器可以在不改动原函数的情况下，对函数增加一些功能。比如打log。
- 多个装饰器的话，从内到外执行。

## 一些面试问题

- `__init__`和`__new__`方法有什么区别？

  - Python中调用构造器创建对象属于两阶段构造过程，首先执行`__new__`方法获得保存对象所需的内存空间，再通过`__init__`执行对内存空间数据的填充（对象属性的初始化）。
  - `__new__`方法的返回值是创建好的Python对象（的引用），而`__init__`方法的第一个参数就是这个对象（的引用），所以在`__init__`中可以完成对对象的初始化操作。`__new__`是类方法，它的第一个参数是类，`__init__`是对象方法，它的第一个参数是对象。

- 迭代器和生成器

  - 如何更好地理解Python迭代器和生成器？ - 赖明星的回答 - 知乎 https://www.zhihu.com/question/20829330/answer/133606850
  
- 的

- 的

- 

- 

- 

- 

- 

- 



  

  

  

  
